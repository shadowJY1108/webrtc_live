<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>webrtc mesh demo</title>
    <link rel="stylesheet" type="text/css" href="./assets/index.css">
    <!-- 引入 layui.css -->
    <link href="/signalServerMesh/node_modules/layui/dist/css/layui.css" rel="stylesheet">
</head>

<body>

    <div class="join" style="display: block;">
        <input type="text" id="input_nickname" placeholder="请输入会议昵称">
        </br>
        <input type="text" id="input_roomid" placeholder="请输入会议号">
        </br>
        <button id="conn">加入会议</button>
    </div>


    <div class="room" style="display: none;">

        <div class="roomshow">

            <div class="videoContainer">

                <div class="topTool">
                    <div class="showChart">
                        <button type="button" class="layui-btn layui-btn-sm" id="shownet" onclick="shownet()">
                            <i class="layui-icon layui-icon-wifi"></i>
                        </button>
                    </div>

                    <!-- 设置码率 -->
                    <div class="bandwidth layui-form">
                        <select id="bandwidthSelect" lay-filter="bandwidthSelect" >
                            <option value="">&#xe628; 更改码率</option>
                            <option value="4096"> 4096 kbps </option>
                            <option value="2048"> 2048 kbps </option>
                            <option value="1024"> 1024 kbps </option>
                            <option value="512"> 512 kbps </option>
                            <option value="128"> 128 kbps </option>
                        </select>

                        <!-- <div>
                            <button type="button" class="layui-btn layui-btn-sm" id="updateBitrate"
                                onclick="updateBitrate()">
                                <i class="layui-icon layui-icon-engine" style="font-size: 12px;">更改码率</i>
                            </button>
                        </div> -->

                    </div>

                </div>

                <div class="videoBox">
                    <div class="localVideoBox">
                        <video id="localvideo" autoplay></video>
                    </div>

                    <div class="remoteVideoBox">
                    </div>

                </div>

                <div class="toolbtn">
                    <div class="lefticon">
                        <div id="muteMic">
                            <i class="layui-icon layui-icon-mike"></i>
                            <p>解除静音</p>
                        </div>
                        <select class="arrow" id="audioSourceSelect"></select>
                        <div id="closeCamera">
                            <i id="cameraOpen" class="layui-icon layui-icon-video"></i>
                            <i id="cameraClosed" class="layui-icon  layui-icon-tips-fill" style="display:none;"></i>
                            <p id="closeCameraText">关闭视频</p>
                        </div>
                        <select class="arrow" id="videoSourceSelect"></select>
                    </div>

                    <div class="middleicon">
                        <div id="share">
                            <i class="layui-icon layui-icon-chart-screen"></i>
                            <p>共享</p>
                        </div>
                        <div>
                            <i class="layui-icon layui-icon-question"></i>
                            <p>举手</p>
                        </div>
                        <div>
                            <i class="layui-icon layui-icon-radio"></i>
                            <p>录制</p>
                        </div>
                        <div id="chatIcon">
                            <i class="layui-icon  layui-icon-reply-fill"></i>
                            <p>消息</p>
                        </div>
                        <div id="chatIcon">
                            <i class="layui-icon  layui-icon-layouts"></i>
                            <p>布局</p>
                        </div>

                        <div id="leave">
                            <i class="layui-icon layui-icon-logout"></i>
                            <p>离开会议</p>
                        </div>
                    </div>

                </div>
            </div>

            <div class="msgContainer">
                <div class="show_msg">
                    <!-- <h2>Chat:</h2> -->
                    <textarea id="output_chat" disabled></textarea>
                </div>
                <div class="input_text">
                    <textarea id="input_chat"></textarea>

                </div>
                <div class="sendbtnBox">
                    <button id="sendmsg">发送</button>
                </div>
            </div>
        </div>

        <div id="chartBox">
            <canvas id="myChart"></canvas>
        </div>
    </div>

    <script src="https://cdn.staticfile.org/Chart.js/3.9.1/chart.js"></script>

    <script src="/signalServerMesh/node_modules/socket.io-client/dist/socket.io.min.js"></script>
    <script src="/signalServerMesh/node_modules/layui/dist/layui.js"></script>

    <script>
        const join = document.querySelector('.join')
        const room = document.querySelector('.room')
        const btnConn = document.querySelector('#conn')
        const input_nickname = document.querySelector('#input_nickname')

        const localvideo = document.querySelector('#localvideo')
        const remoteVideoBox = document.querySelector('.remoteVideoBox')

        const msgContainer = document.querySelector('.msgContainer')
        const show_msg = document.querySelector('.show_msg')
        const input_chat = document.querySelector('#input_chat')
        const output_chat = document.querySelector('#output_chat')
        const btnSendMsg = document.querySelector('#sendmsg')

        const offer = document.querySelector('#offer')
        const answer = document.querySelector('#answer')

        const shareIcon = document.querySelector('#share')
        const closeCameraIcon = document.querySelector('#closeCamera')
        const chatIcon = document.querySelector('#chatIcon')
        const btnLeave = document.querySelector('#leave')

        var localStream = null;
        var newLocalStream = null;
        var remoteStream = null;

        var currentVideoTrack
        var canvasTrack

        var state = 'init'
        var roomid = '111111'
        var socket

        var myid
        var userlist

        var pcConfig = {
            'iceServers': [{
                urls: 'turn:60.204.175.114:3478',
                username: 'jy02',
                credential: '123456',
            }]
        }

        var PCs = {}
        var DCs = {};

        // 1.获取本地流
        btnConn.onclick = () => {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                console.error('not supported!');
                return;
            } else {
                var constrains = {
                    video: {
                        width: { ideal: 1920, min: 1280 },
                        height: { ideal: 1080, min: 720 }
                    },
                    audio: true,
                    frameRate: 25,
                }
                if (input_nickname.value.length == 0) {
                    alert('昵称不能为空')
                } else {
                    myid = input_nickname.value
                    join.style.display = 'none'
                    room.style.display = 'block'
                    // 获取getUserMedia流，设置在本地元素同时返回设备清单，获取设备清单，连接io
                    navigator.mediaDevices.getUserMedia(constrains)
                        .then(getMediaStream)
                        .then(gotDevices)
                        .then(conn)
                        .catch(handleError)
                }
            }
        }
        // 关闭本地媒体流
        function closeLocalMedia() {
            if (localStream && localStream.getTracks()) {
                localStream.getTracks().forEach(track => {
                    track.stop()
                })
            }
        }

        const localVideoBox = document.querySelector('.localVideoBox')
        // 将本地流设置在本地video元素
        function getMediaStream(stream) {
            localvideo.srcObject = stream;
            localStream = stream;
            currentVideoTrack = localStream.getVideoTracks()[0];
            return navigator.mediaDevices.enumerateDevices()
        }

        // 获取远端流将远端渲染至页面
        function getRemoteStream(e) {
            console.log('OnTrack:', e);
            if (e.track.kind === 'video') {
                const newRemoteVideo = document.createElement('video')
                newRemoteVideo.autoplay = true;
                // newRemoteVideo.style.setProperty('aspect-ratio', '16 / 9');
                remoteVideoBox.appendChild(newRemoteVideo)
                newRemoteVideo.srcObject = e.streams[0];
                remoteVideoBox.style.display = 'flex'
            }
            if (e.track.kind === 'auido') {
                const newRemoteAudio = document.createElement('audio')
                newRemoteAudio.autoplay = true;
                remoteVideoBox.appendChild(newRemoteAudio)
                newRemoteVideo.srcObject = e.streams[0];
            }
        }


        // 3.client singal
        function conn() {
            socket = io('https://110.42.189.229:8009',
                {
                    query: {
                        roomid: '111111',
                        myid: myid,
                    }
                }
            )
            // 建立连接后，加入房间
            socket.emit('join', roomid)

            socket.on('userList', (users, roomid) => {
                console.log('receive message: 房间ID:' + roomid + '，用户：' + users);
                userlist = users
                // console.log(userlist);
            })

            socket.on('joined', (roomid) => {
                console.log('receive joined messgae: ', roomid);
                state = 'joined'
                console.log('update: state=', state);
                if (userlist.length == 0) {
                    return console.log('只有你一个人在房间', userlist.length);
                } else {
                    console.log(userlist.length);
                    for (i = 0; i < userlist.length; i++) {
                        // console.log(userlist[i]);
                        createPeerConnection(userlist[i])
                    }
                }

            })

            socket.on('joinError', err => {
                alert(err.msg);
                closePeerConnection(err.id)
                closeLocalMedia()
                join.style.display = 'block'
                room.style.display = 'none'
                // closePeerConnection()     
            })

            socket.on('otherjoin', (roomid, otherid) => {
                console.log('receive otherjoined message:', roomid, state, otherid);
                // if (state === 'joined_unbind') {
                //     console.log('没有执行-·-');
                //     createPeerConnection()
                // }
                createPeerConnection(otherid)

                DCs[otherid] = PCs[otherid].createDataChannel('chatchannel');
                DCs[otherid].onmessage = receivemsg;

                // 由joined_conn发起call
                state = 'joined_conn'
                console.log('update: state=', state);
                var options = {
                    offerToReceiveAudio: 1,
                    offerToReceiveVideo: 1,
                }
                // console.log(PCs);
                PCs[otherid].createOffer(options)
                    .then(desc => {
                        PCs[otherid].setLocalDescription(desc)
                        console.log('show desc', desc);
                        socket.emit('message', roomid, {
                            type: desc.type,
                            offer: desc,
                            remote_user: otherid,
                            local_user: myid
                        })
                    })
                    .catch(handleOfferError)

            })

            socket.on('full', (roomid, id) => {
                console.log('receive full msg: ', roomid, id);
                state = 'leaved'
                socket.disconnect()
                console.log('receive full message, state=', state);
                alert('the room is full')
            })

            socket.on('leaved', (roomid, id) => {
                console.log('receive leaved msg: ', roomid, id);
                state = 'leaved'
                for (let key in PCs) {
                    closePeerConnection(key)
                    console.log(myid + ' close PeerConnection[' + key + ']');
                }
                socket.disconnect()
                console.log('receive leaved message, state=', state);
            })

            socket.on('bye', (roomid, id) => {
                console.log('receive bye msg: ', roomid, id);
                state = 'joined_unbind'
                closePeerConnection(id)
                remote_container.removeChild(remote_container.childNodes[0])
                console.log('receive bye messgae: state=', state);
            })

            socket.on('disconnect', (socket) => {
                console.log('receive disconnect message!', roomid);
                state = 'leaved';
                console.log('receive disconnect message, state=', state);
            });

            socket.on('message', (roomid, data) => {
                // 媒体协商
                if (data) {
                    if (data.type === 'offer') {
                        console.log('receive offer message :', roomid, data);
                        PCs[data.remote_user].setRemoteDescription(new RTCSessionDescription(data.offer))
                        PCs[data.remote_user].createAnswer()
                            .then(desc => {
                                PCs[data.remote_user].setLocalDescription(desc)
                                socket.emit('message', roomid, {
                                    type: desc.type,
                                    answer: desc,
                                    remote_user: data.remote_user,
                                    local_user: data.local_user
                                })
                            })
                            .catch(handleAnswerError)
                    } else if (data.type === 'answer') {
                        console.log('receive answer message :', roomid, data);
                        PCs[data.remote_user].setRemoteDescription(new RTCSessionDescription(data.answer))
                    } else if (data.type === 'candidate') {
                        console.log('receive candidate message :', roomid, data);
                        // var candidate = new RTCIceCandidate({
                        //     sdpMlineIndex: data.label,
                        //     candidate: data.candidate
                        // })
                        PCs[data.remote_user].addIceCandidate(data.candidate);
                        console.log('addIceCandidate');
                    } else {
                        console.error('this message is invalid!');
                    }
                }
            })

        }


        function leave() {
            if (socket) {
                socket.emit('leave', '111111', myid)
            }
            closeLocalMedia()
            join.style.display = 'block'
            room.style.display = 'none'
            //断开连接在服务端做，断开成功在onleaved
        }
        btnLeave.onclick = leave

        // 4.创建pc实例，获取candidate
        function createPeerConnection(remoteid) {
            console.log('start create RTCpeerconnection!');
            const pc = new RTCPeerConnection(pcConfig)
            PCs[remoteid] = pc
            PCs[remoteid].onicecandidate = e => {
                if (e.candidate) {
                    console.log('find an new candidate:', e.candidate);
                    console.log('send candidate:', e.candidate);
                    sendMessage(roomid, {
                        type: 'candidate',
                        // label: e.candidate.sdpMLineIndex,
                        // id: e.candidate.sdpMid,
                        candidate: e.candidate,
                        remote_user: remoteid,
                        local_user: myid
                    })
                } else {
                    console.log('木有了！');
                }
            }
            console.log(PCs[remoteid]);
            console.log('addTrack:');
            localStream.getTracks().forEach(track => {
                PCs[remoteid].addTrack(track, localStream);
            });

            PCs[remoteid].ontrack = getRemoteStream

            PCs[remoteid].ondatachannel = e => {
                if (!DCs[remoteid]) {
                    DCs[remoteid] = e.channel;
                    DCs[remoteid].onmessage = receivemsg;
                }
            }

        }

        // 销毁pc
        function closePeerConnection(remoteid) {
            console.log('start close RTCpeerconncetion[' + remoteid + ']');
            if (PCs[remoteid]) {
                PCs[remoteid].close()
                PCs[remoteid] = null
            }
        }

        // dataChannel
        function sendText() {
            var data = input_chat.value
            if (data != null) {
                for (let key in DCs) {
                    DCs[key].send(data)
                    console.log(myid + ' send dataChannel to [' + key + ']');
                }
            }
            //showmsg
            input_chat.value = "";
            output_chat.value = output_chat.value + '\r\n' + myid + ':' + data;
        }
        btnSendMsg.onclick = sendText

        function receivemsg(e) {
            var msg = e.data;
            console.log(e);
            if (msg) {
                output_chat.value += msg.id + ':' + msg + "\r\n";
            } else {
                console.error('received msg is null');
            }
        }


        // 创建offer、answer
        // function getOffer(desc) {
        //     pc.setLocalDescription(desc)
        //     console.log('send offer:');
        //     sendMessage(roomid, desc)
        // }

        function sendMessage(roomid, data) {
            // console.log('send p2p message:', roomid, data);
            if (socket) {
                socket.emit('message', roomid, data)
            }
        }

        // 6. icon 功能实现
        // peer中换轨
        async function replaceTracks(newTrack) {
            for (key in PCs) {
                // console.log(PCs[key]);
                const sender = PCs[key].getSenders().find(sender => {
                    return sender.track.kind === newTrack.kind
                })
                console.log('sender:', sender);
                if (!sender) {
                    console.warn('failed to find sender');
                    return;
                }
                await sender.replaceTrack(newTrack);
            }
        }


        /* 6.1getdisplay and share
            目前实现share desk 单流替换medidaTrack，除了本地换还需要在peer中换轨
            待更新:1.share之后布局调整 2.share之后双流 */
        async function shareDesk() {
            const displayStream = await navigator.mediaDevices.getDisplayMedia()
            console.log(displayStream);
            const displayTrack = displayStream.getVideoTracks()[0]
            if (displayTrack) {
                console.log('replace camera track with screen track');
                replaceTracks(displayTrack)
                localvideo.srcObject = displayStream
            }
        }
        shareIcon.onclick = shareDesk

        // 6.2 camera state
        // a.createCanvasStream，这里通过创建创建静态图像cavas流，获取静态图像轨
        function createCanvasStream() {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const placeholderImage = new Image();
            placeholderImage.src = './assets/image/xingkong.jpg';
            placeholderImage.onload = function () {
                canvas.width = 1920
                canvas.height = 1080
                context.drawImage(placeholderImage, 0, 0, canvas.width, canvas.height);
            };
            const canvasStream = canvas.captureStream();
            canvasTrack = canvasStream.getVideoTracks()[0]
            console.log(canvasTrack);
            currentVideoTrack = canvasTrack
            localStream.addTrack(canvasTrack)
            replaceTracks(canvasTrack)
        }

        // b.close and open camera 调用图像轨替换
        const closeCameraText = document.querySelector('#closeCameraText')
        const cameraOpen = document.querySelector('#cameraOpen')
        const cameraClosed = document.querySelector('#cameraClosed')
        async function closeCamera() {
            console.log('即将关闭camera:' + currentVideoTrack.readyState, currentVideoTrack);
            // 方案1：目前了解到的stop停止后无法重启，remove这个轨重新获取并addtrack,本地和peer中都需要添加,注意流中的轨道都移除peer会关闭
            /*     if (oldVideoTrack.readyState === 'ended') {
                    let newStream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            width: { ideal: 1920, min: 1280 },
                            height: { ideal: 1080, min: 720 }
                        }
                    })
                    localStream.removeTrack(oldVideoTrack)
                    localStream.addTrack(newStream.getVideoTracks()[0])
                    oldVideoTrack = newStream.getVideoTracks()[0]
                    console.log('camera open:' + newStream.getVideoTracks()[0].readyState, newStream.getVideoTracks()[0]);
                    closeCameraText.innerHTML = '关闭视频'
                    cameraOpen.style.display = 'block'
                    cameraClosed.style.display = 'none'
                    replaceTracks(newStream.getVideoTracks()[0])
                } else {
                    oldVideoTrack.stop()
                    console.log('camera closed:' + oldVideoTrack.readyState, oldVideoTrack);
                    closeCameraText.innerHTML = '打开视频'
                    cameraOpen.style.display = 'none'
                    cameraClosed.style.display = 'block'
                } */

            // 方案二:cavas流，获取静态图像轨进行占位，解决黑屏问题
            if (currentVideoTrack instanceof CanvasCaptureMediaStreamTrack) {
                // 判断为canvas则重新获取camera流
                let newStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 1920, min: 1280 },
                        height: { ideal: 1080, min: 720 }
                    }
                })
                localStream.removeTrack(canvasTrack)
                localStream.addTrack(newStream.getVideoTracks()[0])
                currentVideoTrack = newStream.getVideoTracks()[0]
                console.log('camera open:' + newStream.getVideoTracks()[0].readyState, newStream.getVideoTracks()[0]);
                closeCameraText.innerHTML = '关闭视频'
                cameraOpen.style.display = 'block'
                cameraClosed.style.display = 'none'
                replaceTracks(newStream.getVideoTracks()[0])
            } else {
                // 当前不是canvas流，则创建
                currentVideoTrack.stop()
                localStream.removeTrack(currentVideoTrack)
                createCanvasStream()
                closeCameraText.innerHTML = '打开视频'
                cameraOpen.style.display = 'none'
                cameraClosed.style.display = 'block'
            }
        }
        closeCameraIcon.onclick = closeCamera

        // c.open and close mic 暂时不写...

        // 6.3 change devices
        // 获取所有媒体设备，获取新的stream，onchange事件触发切换
        var audioSourceSelect = document.querySelector("#audioSourceSelect");
        var videoSourceSelect = document.querySelector("#videoSourceSelect");
        // const selectors = [audioSourceSelect, videoSourceSelect];
        function gotDevices(deviceInfos) {
            deviceInfos.forEach(deviceInfo => {
                var option = document.createElement('option');
                option.text = deviceInfo.label;
                option.value = deviceInfo.deviceId;
                if (deviceInfo.kind === 'audioinput') {
                    audioSourceSelect.appendChild(option);
                } else if (deviceInfo.kind === 'videoinput') {
                    videoSourceSelect.appendChild(option);
                }
            });
        }

        function getNewStream(stream) {
            newLocalStream = stream
        }

        async function changeVideoDevice() {
            const videoSource = videoSourceSelect.value;
            const newConstraints = {
                video: {
                    width: { ideal: 1920, min: 1280 },
                    height: { ideal: 1080, min: 720 },
                    deviceId: videoSource ? { exact: videoSource } : undefined
                }
            };
            await navigator.mediaDevices.getUserMedia(newConstraints)
                .then(getNewStream)
                .catch(handleError);
            if (currentVideoTrack instanceof CanvasCaptureMediaStreamTrack) {
                localStream.removeTrack(currentVideoTrack)
                localStream.addTrack(newLocalStream.getVideoTracks()[0])
                currentVideoTrack = newLocalStream.getVideoTracks()[0]
                replaceTracks(newLocalStream.getVideoTracks()[0])
                closeCameraText.innerHTML = '关闭视频'
                cameraOpen.style.display = 'block'
                cameraClosed.style.display = 'none'
                console.log('canvas-->camera成功:', currentVideoTrack.label);
            } else {
                localStream.removeTrack(currentVideoTrack)
                currentVideoTrack.stop()
                localStream.addTrack(newLocalStream.getVideoTracks()[0])
                replaceTracks(newLocalStream.getVideoTracks()[0])
                currentVideoTrack = newLocalStream.getVideoTracks()[0]
                console.log(currentVideoTrack);
                console.log('camera-->camera成功-->', currentVideoTrack.label);
            }

        }
        // audioSourceSelect.onchange = changeDevice
        videoSourceSelect.onchange = changeVideoDevice


        // 6.4 chat
        var chatFlag = true
        function chat() {
            if (chatFlag) {
                msgContainer.style.display = 'block'
                chatFlag = false
            } else {
                msgContainer.style.display = 'none'
                chatFlag = true
            }
        }
        chatIcon.onclick = chat

        // 6.5 Mediarecoder


        // 7.0 setParameters
        // const bandwidthSelect = document.querySelector('#bandwidthSelect')
        layui.use('form', () => {
            var form = layui.form;

            // 监听select的change事件
            form.on('select(bandwidthSelect)', value => {
                let bitrate = value.value;
                console.log('set bitrate to:' + bitrate + 'kbps');
                bitrate = bitrate * 1000;

                for (key in PCs) {
                    // console.log(PCs[key]);
                    PCs[key].getSenders().forEach(sender => {
                        if (sender.track.kind === 'aduio')
                            return;

                        let param = sender.getParameters()
                        param.encodings[0].maxBitrate = bitrate
                        sender.setParameters(param)
                            .then(() => {
                                param = sender.getParameters()
                                console.log('video Sender Encodings:' + key);
                                const senderParamsEncoding = param.encodings.map(encoding =>
                                    JSON.stringify(encoding)).join('\n')
                                console.log(senderParamsEncoding);
                            })
                            .catch(error => {
                                console.error("set MaxBitrate error!" + error.name);
                            })
                    })
                }
            });

            form.render();
        });

        // function updateBitrate() {
        //     let bitrate = bandwidthSelect.value;
        //     console.log('set bitrate to:' + bitrate + 'kbps');
        //     bitrate = bitrate * 1000;

        //     for (key in PCs) {
        //         // console.log(PCs[key]);
        //         PCs[key].getSenders().forEach(sender => {
        //             if (sender.track.kind === 'aduio')
        //                 return;

        //             let param = sender.getParameters()
        //             // console.log(param);
        //             // console.log(sender.getStats());
        //             param.encodings[0].maxBitrate = bitrate
        //             sender.setParameters(param)
        //                 .then(() => {
        //                     param = sender.getParameters()
        //                     console.log('video Sender Encodings:' + key);
        //                     const senderParamsEncoding = param.encodings.map(encoding =>
        //                         JSON.stringify(encoding)).join('\n')
        //                     console.log(senderParamsEncoding);
        //                 })
        //                 .catch(error => {
        //                     console.error("set MaxBitrate error!" + error.name);
        //                 })
        //         })
        //     }
        // }

        // 7.1呼叫信息查询
        let netFlag = 0
        function shownet() {
            const chart = document.querySelector('#chartBox')
            if (netFlag === 0) {
                chart.style.zIndex = 3
                netFlag = 1
            } else {
                chart.style.zIndex = 1
                netFlag = 0
            }

        }

        // chart
        // const myChart = document.querySelector('#myChart')
        let myChart = null
        let chartLabels = []
        let chartVideoSent = []
        let chartVideoReceive = []
        let chartAudioSent = []
        let chartAudioReceive = []

        const chartColors = {
            red: 'rgb(255, 99, 132)',
            orange: 'rgb(255, 159, 64)',
            yellow: 'rgb(255, 205, 86)',
            green: 'rgb(75, 192, 192)',
            blue: 'rgb(54, 162, 235)',
            purple: 'rgb(153, 102, 255)',
            grey: 'rgb(201, 203, 207)'
        };

        function drawChart() {
            const ctx = document.getElementById('myChart')

            myChart = new Chart(ctx, {
                type: 'line',

                data: {
                    labels: chartLabels,
                    datasets: [
                        {
                            label: 'Video Sent',
                            backgroundColor: chartColors.red,
                            borderColor: chartColors.red,
                            fill: false,
                            data: chartVideoSent
                        },
                        {
                            label: 'Video Receive',
                            backgroundColor: chartColors.orange,
                            borderColor: chartColors.orange,
                            fill: false,
                            data: chartVideoReceive
                        },
                        {
                            label: 'Audio Sent',
                            backgroundColor: chartColors.green,
                            borderColor: chartColors.green,
                            fill: false,
                            data: chartAudioSent
                        },
                        {
                            label: 'Audio Receive',
                            backgroundColor: chartColors.blue,
                            borderColor: chartColors.blue,
                            fill: false,
                            data: chartAudioReceive
                        }
                    ]
                },

                options: {
                    responsive: true,
                    hoverMode: 'index',
                    stacked: false,
                    title: {
                        display: true,
                        text: '实时码率(kbps)'
                    },
                    scales: {
                        yAxes: [{
                            type: 'linear',
                            display: true,
                            position: 'left',
                        }],
                    }
                }
            });
        }
        drawChart()

        function updateStats() {
            // let receivedAudioBytes = 0;
            let receivedVideoBytes = 0;
            // let sentAudioBytes = 0;
            let sentVideoBytes = 0;

            function getCurrentTime() {
                var now = new Date();

                var hours = now.getHours();
                var minutes = now.getMinutes();
                var seconds = now.getSeconds();

                // 确保小时、分钟和秒数始终是两位数，不足补零
                hours = (hours < 10 ? '0' : '') + hours;
                minutes = (minutes < 10 ? '0' : '') + minutes;
                seconds = (seconds < 10 ? '0' : '') + seconds;

                var currentTime = hours + ':' + minutes + ':' + seconds;

                return currentTime;
            }

            setInterval(async () => {
                for (key in PCs) {
                    const rtpReceivers = PCs[key].getReceivers();
                    const rtpVideoReceiver = rtpReceivers.find(rece => rece.track.kind === 'video');
                    // const rtpAudioReceiver = rtpReceivers.find(rece => rece.track.kind === 'audio');

                    const rtpSenders = PCs[key].getSenders();
                    const rtpVideoSender = rtpSenders.find(sender => sender.track.kind === 'video');
                    // const rtpAudioSender = rtpSenders.find(sender => sender.track.kind === 'audio');

                    const receVideoStats = await rtpVideoReceiver.getStats();
                    // const receAudioStats = await rtpAudioReceiver.getStats();
                    const sendVideoStats = await rtpVideoSender.getStats();
                    // const sendAudioStats = await rtpAudioSender.getStats();

                    // let inboundAudioRtpStat;
                    let inboundVideoRtpStat;
                    let outboundAudioRtpStat;
                    // let outboundVideoRtpStat;

                    receVideoStats.forEach(stat => {
                        // console.log(stat.type);
                        if (stat.type === 'inbound-rtp') {
                            // log(`trackId: ${stat.trackId}`);
                            // console.log(stat);
                            const packetsLost = stat.packetsLost;
                            console.log('packetsLost:', packetsLost);
                            inboundVideoRtpStat = stat;
                        }

                    });

                    // receAudioStats.forEach(stat => {
                    //     if (stat.type === 'inbound-rtp') {
                    //         // log(`trackId: ${stat.trackId}`);
                    //         inboundAudioRtpStat = stat;
                    //     }
                    // });

                    sendVideoStats.forEach(stat => {
                        if (stat.type === 'outbound-rtp') {
                            // console.log(stat)
                            outboundVideoRtpStat = stat;
                        }
                    });

                    // sendAudioStats.forEach(stat => {
                    //     if (stat.type === 'outbound-rtp') {
                    //         outboundAudioRtpStat = stat;
                    //     }
                    // });


                    // const receAudioRate = inboundAudioRtpStat.bytesReceived - receivedAudioBytes;
                    const receVideoRate = inboundVideoRtpStat.bytesReceived - receivedVideoBytes;
                    // const sentAudioRate = outboundAudioRtpStat.bytesSent - sentAudioBytes;
                    const sentVideoRate = outboundVideoRtpStat.bytesSent - sentVideoBytes;
                    // receivedAudioBytes = inboundAudioRtpStat.bytesReceived;
                    receivedVideoBytes = inboundVideoRtpStat.bytesReceived;
                    // sentAudioBytes = outboundAudioRtpStat.bytesSent;
                    sentVideoBytes = outboundVideoRtpStat.bytesSent;

                    // 将startTime递增，转换为字符串，追加到chartLabels数组中
                    chartLabels.push(getCurrentTime());

                    chartVideoReceive.push(Math.floor(receVideoRate * 8 / 1000 / 5));
                    chartVideoSent.push(Math.floor(sentVideoRate * 8 / 1000 / 5));
                    // chartAudioReceive.push(Math.floor(receAudioRate * 8 / 1024));
                    // chartAudioSent.push(Math.floor(sentAudioRate * 8 / 1024));

                    // 更新图表
                    myChart.update();
                }

            }, 5000);
        }
        updateStats()



        // 9.错误处理
        function handleError(err) {
            console.error('failed to get mediaSteam!', err)
        }

        function handleAnswerError(err) {
            console.error('failed to get answer!', err)
        }

        function handleOfferError(err) {
            console.error('failed to get offer!', err)
        }

    </script>


    <!-- <script src="adapter"></script> -->


    <!-- <script src="/node_modules/chart.js/dist/chart.js"></script> -->
</body>

</html>